# System Architecture

This document provides a high-level overview of the LED Chess Board system, explaining how hardware and software components integrate to create an interactive chess experience.

## System Overview

The LED Chess Board is a mechatronic system that combines embedded hardware control with chess game logic. The system takes user input through a serial interface, processes moves using an on-board chess algorithm, and provides visual feedback through a grid of 64 individually-controlled LEDs.

### Core Components

```
┌─────────────────────────────────────────────────────────┐
│                    USER INTERFACE                        │
│                   (Serial Monitor)                       │
└────────────────────┬───────────────────────────────────┘
                     │ Serial Commands (9600 baud)
                     ▼
┌─────────────────────────────────────────────────────────┐
│              ARDUINO MEGA 2560                           │
│  ┌─────────────────────────────────────────────────┐   │
│  │         Chess Algorithm (Micro-Max)              │   │
│  │  - Move validation & generation                  │   │
│  │  - Position evaluation                           │   │
│  │  - AI opponent logic                             │   │
│  └────────────────┬─────────────────────────────────┘   │
│                   │                                      │
│  ┌────────────────▼─────────────────────────────────┐   │
│  │      Hardware Abstraction Layer                  │   │
│  │  - LED control functions                         │   │
│  │  - MUX channel management                        │   │
│  │  - Binary encoding                               │   │
│  └────────────────┬─────────────────────────────────┘   │
└───────────────────┼──────────────────────────────────────┘
                    │ 20 Digital I/O Pins
                    ▼
┌─────────────────────────────────────────────────────────┐
│        MULTIPLEXER CONTROL LAYER                         │
│  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐  │
│  │  MUX 0   │ │  MUX 1   │ │  MUX 2   │ │  MUX 3   │  │
│  │ (A1-D4)  │ │ (E1-H4)  │ │ (A5-D8)  │ │ (E5-H8)  │  │
│  │16 channels│ │16 channels│ │16 channels│ │16 channels│  │
│  └────┬─────┘ └────┬─────┘ └────┬─────┘ └────┬─────┘  │
└───────┼────────────┼────────────┼────────────┼─────────┘
        │            │            │            │
        └────────────┴────────────┴────────────┘
                     │ 64 LED Channels
                     ▼
┌─────────────────────────────────────────────────────────┐
│                   LED MATRIX                             │
│               64 Individual LEDs                         │
│              (8×8 Chess Board)                           │
└─────────────────────────────────────────────────────────┘
```

## Data Flow

### 1. User Input → Chess Logic

**Process:**
1. User enters move via serial monitor (e.g., "move e2e4")
2. Arduino receives command through UART serial interface
3. Input parser extracts source and destination squares
4. Chess algorithm validates move legality
5. If valid, board state updates

**Key Functions:**
- `Serial.available()` - Checks for incoming data
- Move parser - Converts algebraic notation to board positions
- `validateMove()` - Ensures move follows chess rules

### 2. Chess Logic → AI Response

**Process:**
1. After human move, AI calculates best response
2. Micro-Max engine evaluates possible positions
3. Best move selected based on minimax algorithm with alpha-beta pruning
4. AI move applied to board state

**Performance:**
- Move calculation: <10 seconds typical
- Search depth: Adjustable based on difficulty
- Memory usage: ~20% of available flash

### 3. Move Visualization → Hardware Control

**Process:**
1. AI move (e.g., "e7e5") extracted from chess engine
2. Source square (e7) and destination square (e5) identified
3. Algebraic notation converted to MUX/channel pairs
4. LED control functions activate corresponding lights
5. Non-blocking blink animation shows the move

**Translation Example:**
```
Move: e7e5
  ↓
Source: e7 → MUX 3, Channel 14
Dest:   e5 → MUX 3, Channel 12
  ↓
Blink both LEDs to indicate computer's move
```

## Hardware-Software Integration

### Pin Assignment Strategy

The system uses 20 Arduino pins to control 64 LEDs through a hierarchical control structure:

```
20 Arduino Pins
  ↓
4 Multiplexers (6 pins each: 4 control + 1 signal + 1 enable)
  ↓
64 Individual LED Channels (16 per MUX)
```

**Pin Efficiency Calculation:**
- Direct control: 64 pins required
- With multiplexers: 20 pins required
- Reduction: 69% fewer pins used

### Multiplexer Control

Each multiplexer requires 6 Arduino pins:

1. **S0-S3 (Control Pins):** 4-bit binary input selects one of 16 channels
2. **SIG (Signal Pin):** HIGH/LOW controls LED state
3. **EN (Enable Pin):** Active LOW enables the multiplexer

**Example - Lighting square E2:**
```cpp
// E2 maps to MUX 1, Channel 2
// Binary: 0010

digitalWrite(MUX_PINS[1][0], 0);  // S0 = 0
digitalWrite(MUX_PINS[1][1], 1);  // S1 = 1
digitalWrite(MUX_PINS[1][2], 0);  // S2 = 0
digitalWrite(MUX_PINS[1][3], 0);  // S3 = 0
digitalWrite(MUX_PINS[1][5], LOW); // Enable MUX 1
digitalWrite(MUX_PINS[1][4], HIGH); // Turn LED on
```

### Non-Blocking LED Control

Traditional LED blinking uses `delay()`, which blocks all other operations. This system implements **non-blocking blink** using time-based state management:

```cpp
void updateBlink() {
  if (!blinkingActive) return;
  
  unsigned long currentTime = millis();
  if (currentTime - lastBlinkTime >= BLINK_INTERVAL) {
    lastBlinkTime = currentTime;
    blinkState = !blinkState;
    
    if (blinkState) {
      turnOnLED(srcChannel.mux, srcChannel.channel);
      turnOnLED(dstChannel.mux, dstChannel.channel);
    } else {
      turnOffLED(srcChannel.mux, srcChannel.channel);
      turnOffLED(dstChannel.mux, dstChannel.channel);
    }
  }
}
```

**Benefits:**
- Chess calculation continues during LED animation
- Serial communication remains responsive
- User can interrupt blinking with commands

## Subsystem Descriptions

### Chess Engine Subsystem

**Based on:** Micro-Max by H.G. Muller (adapted by Diego Cueva for Arduino)

**Features:**
- Minimax search algorithm with alpha-beta pruning
- Position evaluation based on material and positional factors
- Full chess rule implementation:
  - Castling (kingside and queenside)
  - En passant capture
  - Pawn promotion
  - Check and checkmate detection

**Memory Optimization:**
- Compact board representation
- Efficient move generation
- Iterative deepening for time management

### LED Control Subsystem

**Responsibilities:**
- Translate chess positions to hardware addresses
- Manage multiplexer channel selection
- Coordinate LED state across all 64 squares
- Provide visual feedback for moves

**Key Design Pattern:**
```
Chess Position (e.g., "e2")
  ↓ getChannelFromPosition()
MUX + Channel (e.g., MUX 1, Channel 2)
  ↓ setMuxChannel()
Binary Control Signals (e.g., 0010)
  ↓ digitalWrite()
Hardware State Change (LED on/off)
```

### User Interface Subsystem

**Serial Commands:**
- `show` - Display current board state in ASCII
- `move e2e4` - Execute human move
- `reset` - Reset board to starting position
- `stop` - Stop LED blinking

**Feedback Mechanisms:**
1. **Text:** ASCII board display in serial monitor
2. **Visual:** LED indicators for computer moves
3. **Status:** Move validation and capture notifications

## System States

### Startup State

**Actions:**
1. Initialize serial communication (9600 baud)
2. Configure all multiplexer pins as outputs
3. Disable all multiplexers (EN pins HIGH)
4. Run startup LED sequence (visual test)
5. Initialize chess board to starting position
6. Display welcome message and command list

### Waiting for Input State

**Behavior:**
- System idle, waiting for serial input
- `updateBlink()` called every loop iteration
- LED animation continues if active
- Minimal power consumption

### Processing Move State

**Actions:**
1. Parse user input
2. Validate move legality
3. Update board state
4. Display updated position
5. Transition to AI calculation

### AI Thinking State

**Actions:**
1. Chess engine evaluates positions
2. Best move calculated (up to 10 seconds)
3. Non-blocking blink continues during calculation
4. Upon completion, transition to move display

### Displaying Move State

**Actions:**
1. Convert AI move to MUX/channel coordinates
2. Activate source and destination LEDs
3. Start blink animation (500ms interval)
4. Return to waiting for input state

## Performance Considerations

### Response Time

- **User move validation:** <100ms
- **AI move calculation:** 1-10 seconds (varies with position complexity)
- **LED update:** <1ms per change
- **Blink interval:** 500ms (user adjustable)

### Memory Usage

- **Program Storage:** ~60KB (20% of 256KB available)
- **SRAM:** ~2KB (25% of 8KB available)
- **Chess algorithm:** Largest component (~50KB)
- **LED control:** Minimal footprint (~5KB)

### Power Consumption

- **Arduino Mega:** ~50mA baseline
- **LEDs:** ~3.3mA each (max 4 simultaneous = 13.2mA)
- **Multiplexers:** <1mA each
- **Total maximum:** ~65mA (well within USB power limits)

## Design Rationale

### Why Multiplexers?

**Problem:** Arduino Mega has 54 I/O pins, but we need 64 for individual LED control.

**Solution:** Use 4× 16-channel multiplexers to expand 20 pins to 64 channels.

**Trade-offs:**
- ✅ Reduces pin requirements by 69%
- ✅ Allows project to be built with available hardware
- ✅ Provides room for future expansion
- ⚠️ Adds complexity to LED addressing
- ⚠️ Requires binary channel encoding

### Why Non-Blocking Blink?

**Problem:** Traditional `delay()` freezes the entire program during LED animation.

**Solution:** Time-based state management using `millis()`.

**Benefits:**
- Chess engine can calculate while LEDs animate
- User can send commands without waiting
- More professional, responsive system behavior

### Why Serial Interface?

**Problem:** Adding physical buttons/display increases cost and complexity.

**Solution:** Use Arduino's built-in serial communication with computer.

**Advantages:**
- No additional hardware required
- Easy debugging and testing
- Flexible command system
- Standard chess notation supported

## Failure Modes & Error Handling

### Invalid Move Input

**Detection:** Chess algorithm validates all moves  
**Response:** Display error message, request new move  
**Recovery:** System remains in waiting state

### Serial Communication Loss

**Detection:** Loss of USB connection  
**Response:** Arduino continues running, no input received  
**Recovery:** Automatic reconnection when USB restored

### LED Malfunction

**Detection:** Visual inspection during startup sequence  
**Response:** Identify faulty LED or connection  
**Recovery:** Hardware debugging required

### Memory Overflow

**Prevention:** Careful variable management, no dynamic allocation  
**Monitoring:** Track SRAM usage during development  
**Status:** Current usage ~25%, safe margin maintained

## Extension Possibilities

The modular architecture allows for future enhancements:

1. **Difficulty Settings:** Adjust AI search depth
2. **Move History:** Store and replay past moves
3. **Opening Book:** Pre-programmed opening sequences
4. **Time Controls:** Add chess clock functionality
5. **Multi-color LEDs:** Use RGB LEDs for richer feedback
6. **Physical Sensors:** Detect piece placement automatically

## Conclusion

The LED Chess Board demonstrates a well-integrated mechatronic system where software algorithms control physical hardware through efficient resource management. The hierarchical architecture allows complex functionality (full chess engine) to run on constrained hardware (8-bit microcontroller) while maintaining responsive user interaction.

Key success factors:
- **Efficient resource usage:** 20% memory, 37% pins
- **Modular design:** Clear separation between chess logic and hardware control
- **Responsive interface:** Non-blocking LED control
- **Complete functionality:** All chess rules implemented
- **Professional integration:** Reliable, repeatable operation

## See Also

- [Multiplexer Implementation](multiplexer-implementation.md) - Deep dive into MUX control
- [LED Mapping](led-mapping.md) - Position to hardware translation
- [Wiring Guide](../hardware/wiring-guide.md) - Physical pin connections
- [Source Code](../src/finalChess.ino) - Complete implementation
